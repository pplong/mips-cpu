1.C言語での実装

・参考文献
http://ja.wikipedia.org/wiki/IEEE_754#32.E3.83.93.E3.83.83.E3.83.88.E5.8D.98.E7.B2.BE.E5.BA.A6
http://news.mynavi.jp/column/architecture/096/
http://www.kumikomi.net/archives/2010/08/ep24suc3.php?page=5
http://hexadrive.sblo.jp/archives/20111116-1.html

・仕様
NaNには対応、非正規化数には対応しない。

NaNはsign = 0、exp = 255でfractionの全bitが立ったものとする。
非正規化数は、入出力ともに(+0)と解釈する。

例外処理
↓
大小の入れ替え
↓
expの差をとる
↓
ガードビット・ラウンドビット・スティッキービットを考慮した加減算
↓
正規化
↓
丸め
↓
丸めでの桁上がりを正規化
↓
答えを返す。

丸めは最近接丸め(偶数丸め)を実装している。

(+0)+(-0) = (+0)
出力が非正規化数(ここではアンダーフロー)の場合は+0
2数の絶対値が等しく、符号が違う場合は+0
となる。
(-0は(-0)+(-0)もしくは、絶対値の等しいa,bでa負b正のときのみ出る)


fadd.cとシミュレータでのテスト方法について記述する。


testgen.cによって、テストケースを生成する。

faddtest.cを用いて、fadd.cをテストできる。

<fadd.cのテストの実行例>
make
./testgen (10秒ほどかかる)
Success
./fadd
Test Finished:200502 cases



testgen.cについて

基本的に、乱数を用いて値を生成し、条件を満たす値を取り出すという方法でテストケースを作成している。

・例外系　　ケース数　　期待される答え
0   +   0:    4           ±0
x   + NaN:  200           NaN
NaN + NaN:  100           NaN
INF + INF:    4         INFかNaN
x   + INF:  200           INF
x   +   0: 2000            x
x   +  -x: 2000           +0
Sub + Sub:   42           +0
Nom + Sub:  950          Nom
合計     :  5500

・通常の計算
情報落ち          :     5000
オーバーフロー     :     5000
アンダーフロー     :     5000
情報落ちなし      :   100000
ガードビットが立つ  :    30000
指数部が同じ      :    50000
丸めの結果桁上がり :        2
合計              :  195002

全体の合計 : 200502 ケース


情報落ち:expの差が26以上の2数を生成
オーバーフロー:float計算の結果、expが255(無限大)となる通常の数を生成
アンダーフロー：float計算の結果、expが0(非正規化数か0)となる通常の数を生成
情報落ちなし:expの差が25以下の2数を生成(通常の計算をする)
ガードビットが立つ:丸めによって桁が上がるもののテストを期待する。
指数部が同じ：加算の正規化、減算の正規化のテストを期待する。
丸めの結果桁上がり：丸めの結果、桁が上がるようなケースを生成する。


・丸めの結果桁上がりのケースについて
i1.sign = 0;i1.exp = 16;i1.frc = 4163463;
i2.sign = 0;i2.exp = 15;i2.frc = 61681;
のケースでは、
i1:0 00010000 0111 1111 0000 1111 0000 111
i2:0 00001111 0000 0001 1110 0001 1110 001
なので、fracとして

  01 0111 1111 0000 1111 0000 111 000
+ 00 1000 0000 1111 0000 1111 000 100
-------------------------------------
  01 1111 1111 1111 1111 1111 111 100
より丸めの結果
  10 0000 0000 0000 0000 0000 000
が発生する。

もうひとつは、
i1:1 10000010 0000 0000 0000 1111 1111 111
i2:1 10000001 1111 1111 1110 0000 0000 001
から
  01 0000 0000 0000 1111 1111 111 000
+ 00 1111 1111 1111 0000 0000 000 100
-------------------------------------
  01 1111 1111 1111 1111 1111 111 100
が丸めで桁上がりして
  10 0000 0000 0000 0000 0000 000
を発生する。


faddtest.cについて

testgen.cによって生成された、input1.bin、input2.bin、output.binを読み、
fadd関数の結果との答え合わせを行う。

output.binにおいて、
NaNが返るときは、frcを全てのbitが立ったものに
非正規化数が返るときは+0に
チューニングする。

失敗した場合はNGを返す。


これにより、faddのテストが完了した。



2.VHDLでの実装

fadd.cのコードをステートマシンを用いつつ、vhdlに移植した。
goを立てて、busyが落ちたら結果を読むことが出来る。


・シミュレータテストについて

top.vhdとtop_tb.vhdを作成した。(vhdltestフォルダ内)

・参考(バイナリファイルをmodelsimで読む方法について参考にした)
http://blog.pld.jp/archives/51029046.html

testgen.cによって生成されたinput1.bin、input2.bin、output.binを読む。
inputの値をfaddに入れ、結果をoutput.binのデータで答え合わせする。

faddtest.c同様、NaNや非正規化数がoutput.binに書いてある場合は、チェックを緩くしている。


1.pngがシミュレートした画像である。
カーソルは答え合わせをしている時点であり、signal o(binから読んできたri1とri2の値をfaddに入れた計算結果)とsignal ro(binに書いてある解答)が一致していることが分かる。
画像の下の方のmodelsimのtranscript欄にreport文による Note : Successが出ている。
(失敗した場合は、Note: Failedが出る)




・基盤でのテストについて

top.vhdを作成。(vhdlfpgaフォルダ内)

シミュレータでのテストから、プログラムは正しく動作すると考え、
ここでは回路が正しく動作していることを確認するため、
各ケースからピックアップしてテストした。

i1                                  i2                                  o
--0+0
1 00000000 00000000000000000000000  0 00000000 00000000000000000000000  0 00000000 00000000000000000000000
1 00000000 00000000000000000000000  1 00000000 00000000000000000000000  1 00000000 00000000000000000000000
--x + NaN
0 00001100 01010101010101010101010  1 11111111 11111111111111111111111  0 11111111 11111111111111111111111
1 11111111 11111111111111111111111  0 11101110 00000000010000000100000  0 11111111 11111111111111111111111
--NaN + NaN
0 11111111 11111111111111111111111  1 11111111 11111111111111111111111  0 11111111 11111111111111111111111
--INF + INF
0 11111111 00000000000000000000000  0 11111111 00000000000000000000000  0 11111111 00000000000000000000000
1 11111111 00000000000000000000000  0 11111111 00000000000000000000000  0 11111111 11111111111111111111111
--x + INF
0 10101010 11110000111100001111000  1 11111111 00000000000000000000000  1 11111111 00000000000000000000000
--x + 0
1 00000000 00000000000000000000000  0 11100000 00000000000000000000001  0 11100000 00000000000000000000001
--x + (-x)
1 00111111 11100000000000000000000  0 00111111 11100000000000000000000  0 00000000 00000000000000000000000
--Sub + Sub
1 00000000 00000000101110000000000  1 00000000 00000000000000001111111  0 00000000 00000000000000000000000
--Nom + Sub
0 00000000 01010101010101010101010  0 00011111 00000000000000000000011  0 00011111 00000000000000000000011
--情報落ち
0 11000000 10000000000000000000000  0 10000000 11111111111110000000000  0 11000000 10000000000000000000000
--オーバーフロー
1 11111110 11111111111111111111111  1 11111110 00000100010100001010000  1 11111111 00000000000000000000000
--アンダーフロー
0 00000001 11100000000000000000001  1 00000001 11100000000000000000000  0 00000000 00000000000000000000000
--正規化なし
0 00001000 00000000000000000001111  0 00000111 10000000000000000000000  0 00001000 11000000000000000001111
--加算の正規化
0 00100000 11100000000000000000001  0 00100001 11000000000000000000000  0 00100010 01011000000000000000000
--減算の正規化
1 11100000 00110000000000000000000  0 11100010 00110000000000000000000  0 11100001 11001000000000000000000
--丸め
0 00000010 00000000000000000000000  0 00000001 00000000000000000000011  0 00000010 10000000000000000000010
--丸めた結果桁上がり
1 10000010 00000000000011111111111  1 10000001 11111111111000000000001  1 10000011 00000000000000000000000
--大きく時間のかかるケース
1 00000010 00000000000000000000000  0 00011011 11111111111111111111111  0 00011011 11111111111111111111111

21cases




これらをROMに入れておいて、比較を行った。

成功した場合は、出力を得るのに何clkかかったかを返す。
全てのケースが成功した場合、FFを返す。途中で失敗した場合はEEを返す。


課題3のDFFによる動作周波数の測定だが、
今回作成したFADDはclk同期のプロセスで書かれているので、clkの1/~倍という形で表現することになる。
そのため、top.vhd内のcountにより簡単にclk数を計測している。

2.pngが結果の画像である。
無事、FFが出力された(動作の確認が出来た)。

2
2
2
2
2
2
2
2
2
6
2
2
4
9
B
A
B
E
A
A
24


というclkで動いたようだ。
例外処理で終わるような場合は、2clkで返ってきている。

指数が離れているほど計算時間がかかるので、
動作周波数の確認として、大きく時間のかかると考えられるケース(指数部の差が25)では、36clkほどかかっている。

FPGA基板は66.66MHzで動いているので、その1/clk倍で考えて、

早い:          33.33MHz
指数部が同じくらい: 5.55～6.66MHz
遅い:          1.85MHz

での動作をした。


・高速化について
今回は、確実に動かすことを考えて、1つ1つのステップがclk同期で動くものを作成した。
しかし、variableなどを用いることで、clk同期のないprocess文を使って作成する事も可能だと考えられ、
その場合より高速な動作が期待できるだろう。
また、そのようにした場合は、DFFを前後にはさむことによる動作周波数の確認は、今回と比べて大きな意味を持つようになるだろうと考える。









